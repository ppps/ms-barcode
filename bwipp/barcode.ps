%!PS

% Barcode Writer in Pure PostScript - Version 2016-11-02
% http://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2014 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN TEMPLATE--

% --BEGIN RESOURCE preamble--
%%BeginResource: Category uk.co.terryburton.bwipp 0.0 2016110200 31191 34576
%%BeginData:          6 ASCII Lines
currentglobal
true setglobal
/Generic /Category findresource dup length 1 add dict copy dup
/InstanceType /setpacking where {pop /packedarraytype} {/arraytype} ifelse put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
%%EndData
%%EndResource
% --END RESOURCE preamble--

% --BEGIN RESOURCE raiseerror--
% --REQUIRES preamble--
%%BeginResource: uk.co.terryburton.bwipp raiseerror 0.0 2016110200 44890 44440
%%BeginData:         13 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/raiseerror {
  $error exch /errorinfo exch put
  $error exch /errorname exch put
  $error /command null put
  $error /newerror true put 
  handleerror quit
} bind def
/raiseerror dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RESOURCE raiseerror--

% --BEGIN RENDERER renlinear--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renlinear 0.0 2016110200 76684 76278
%%BeginData:        237 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renlinear {

    20 dict begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div x add def            % Centre of the bar = x + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add maxh gt {/maxh h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        dup -1 ne {
            aload pop newpath setlinewidth moveto 0 exch rlineto stroke
        } {
            pop
        } ifelse
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                {} forall
                2 copy s ne exch fn ne or {
                    2 copy /s exch def /fn exch def
                    selectfont
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont textsize selectfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renmatrix 0.0 2016110200 80252 80028
%%BeginData:        227 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /barcolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0 def
    /inkspreadh 0 def
    /inkspreadv 0 def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /inkspreadh inkspreadh cvr def
    /inkspreadv inkspreadv cvr def

    inkspread 0 ne {/inkspreadh inkspread def} if
    inkspread 0 ne {/inkspreadv inkspread def} if

    /xyget      { pixx mul add pixs exch get                   } bind def
    /xyinvert   { pixx mul add pixs exch 2 copy get 1 xor put  } bind def
    /mxyget     { pixx mul add m exch get 2#001 and            } bind def
    /mxyset     { pixx mul add m exch 3 -1 roll put            } bind def
    /msetborder { pixx mul add m exch 2 copy get 2#010 or put  } bind def
    /mborderoff { pixx mul add m exch 2 copy get 2#100 or put  } bind def
    /misborder  { pixx mul add m exch get 2#110 and 2#010 eq   } bind def
    /mclear     { pixx mul add m exch 2 copy get 2#001 and put } bind def
    /mclear4 {
        2 copy                       mclear
        2 copy 1 add                 mclear
        2 copy exch 1 add exch       mclear
        2 copy exch 1 add exch       mclear
               1 add exch 1 add exch mclear
    } bind def

    /trace {
        % Walk the outline of a region emitting edge coordinates of the path
        /y exch def  /x exch def
        % dir 0:right 1:down 2:left 3:up
        % hug 0:right 1:left
        /dir x 1 add y 1 add mxyget def  /hug dir def
        /sx x def  /sy y def  /sdir dir def
        mark [x y] {
            x 1 add y
            x 1 add y 1 add
            x       y 1 add
            x       y
            8 dir 2 mul neg roll
            /Dy exch def  /Dx exch def  /D Dx Dy xyget def
            /Cy exch def  /Cx exch def  /C Cx Cy xyget def
            /By exch def  /Bx exch def  /B Bx By xyget def
            /Ay exch def  /Ax exch def  /A Ax Ay xyget def
            A B eq {
                A C eq {/L} {/R} ifelse
            } {
                A C eq B D eq and {
                    A 0 eq hug 0 eq xor {/R} {/F} ifelse
                } {
                    /F
                } ifelse
            } ifelse
            dup /F eq {
                pop
                dir 0 eq {/x x 1 add def} if
                dir 1 eq {/y y 1 add def} if
                dir 2 eq {/x x 1 sub def} if
                dir 3 eq {/y y 1 sub def} if
                hug 0 eq {
                    Ax Ay msetborder
                } {
                    Bx By msetborder
                } ifelse
            } {
                /L eq {
                    /dir dir 3 add 4 mod def
                    hug 1 eq {
                         Bx By msetborder
                         Dx Dy mborderoff
                    } if
                } {  % R
                    /dir dir 1 add 4 mod def
                    hug 0 eq {
                         Ax Ay msetborder
                         Cx Cy mborderoff
                    } if
                } ifelse
                [x y]
            } ifelse
            x sx eq y sy eq and dir sdir eq and {exit} if
        } loop
        counttomark array astore exch pop

        % Invert the interior of the path
        /x x 1 add def /y y 1 add def
        /t x y mxyget 1 xor def
        mark x y {
            counttomark 0 eq {exit} if
            /y exch def /x exch def
            x y mxyget t ne {
                0          x 1 sub -1 0          {dup y misborder {exch pop exit} if pop} for
                pixx 1 sub x 1 add  1 pixx 1 sub {dup y misborder {exch pop exit} if pop} for
                1 exch {  % From left to right border
                    /i exch def
                    i y misborder not {
                        t i y mxyset
                        i y xyinvert
                    } if
                    i y 1 sub mxyget t ne i y 1 sub misborder not and {i y 1 sub} if
                    i y 1 add mxyget t ne i y 1 add misborder not and {i y 1 add} if
                } for
            } if
        } loop
        pop

        % Walk the path to clear the border information
        dup 0 get aload pop /y1 exch def /x1 exch def
        dup dup length 1 sub 1 exch getinterval {
            aload pop /y2 exch def /x2 exch def
            x2 x1 gt { x1  2 x2 1 sub {y1      mclear4} for } if
            y2 y1 gt { y1  2 y2 1 sub {x1 exch mclear4} for } if
            x2 x1 lt { x1 -2 x2 1 add {y1      mclear4} for } if
            y2 y1 lt { y1 -2 y2 1 add {x1 exch mclear4} for } if
            /x1 x2 def /y1 y2 def
        } forall

        % Discard duplicate final point
        dup length 1 sub 0 exch getinterval

    } bind def

    % Pad the bitmap on all sides
    /pixs [
        pixx 2 add {0} repeat
        0 pixx pixs length 1 sub {
            0 exch
            pixs exch pixx getinterval aload pop
            0
        } for
        pixx 2 add {0} repeat
    ] def
    /pixx pixx 2 add def
    /pixy pixy 2 add def

    % Track inverted regions and working space
    /m [ pixs length {0} repeat ] def

    % Construct paths by tracing and inverting each dark region
    /paths [
        0 1 pixy 1 sub {
            /j exch def
            0 1 pixx 1 sub {
                /i exch def
                i j xyget 1 eq {
                    i 1 sub j 1 sub trace
                } if
            } for
        } for
    ] def

    % Revert the bitmap size
    /pixx pixx 2 sub def
    /pixy pixy 2 sub def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    /inkspreadh inkspreadh 2 div def
    /inkspreadv inkspreadv 2 div def
    gsave
    currentpoint translate
    width pixx div 72 mul height pixy div 72 mul scale
    0 0 moveto pixx 0 lineto pixx pixy lineto 0 pixy lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if
    barcolor (unset) ne { barcolor setanycolor } if
    newpath
    paths {
        /p exch def
        /len p length def
        p len 1 sub get aload pop
        p 0 get aload pop
        0 1 len 1 sub {                                % x1 y1 x2 y2
            /i exch def
            p i 1 add len mod get aload pop 6 -2 roll  % x3 y3 x1 y1 x2 y2
            5 index inkspreadh
            4 index 4 -1 roll lt {add} {sub} ifelse    % y3<y1 ? x2+i : x2-i
            4 1 roll
            4 index inkspreadv
            4 index 4 -1 roll gt {add} {sub} ifelse    % x3>x1 ? y2+i : y2-i
            4 -1 roll exch pixy exch sub
            i 0 eq {moveto} {lineto} ifelse
        } for                                          % x2 y2 x3 y3
        closepath
        pop pop pop pop
    } forall
    fill
    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renmaximatrix 0.0 2016110200 55426 55272
%%BeginData:         79 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Default options
    /barcolor (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm

    0 0 moveto 30 0 lineto 30 29 lineto 0 29 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    barcolor (unset) ne { barcolor setanycolor } if

    0.5 0.5774 translate

    newpath
    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath
    } forall
    fill

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean5 0.0 2016110200 62897 62576
%%BeginData:        135 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse

    % Validate input
    barcode length 5 ne {
        /bwipp.ean5badLength (EAN-5 add-on must be 5 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean5badCharacter (EAN-5 add-on must contain only digits) //raiseerror exec
        } if
    } forall
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean2 0.0 2016110200 61678 61382
%%BeginData:        120 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse

    % Validate input
    barcode length 2 ne {
      /bwipp.ean2badLength (EAN-2 add-on must be 2 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean2badCharacter (EAN-2 add-on must contain only digits) //raiseerror exec
        } if
    } forall
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --REQUIRES preamble raiseerror renlinear ean5 ean2--
% --DESC: EAN-13
% --EXAM: 2112345678900
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean13 0.0 2016110200 84460 87603
%%BeginData:        215 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset -10 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    /addontextfont (unset) def
    /addontextsize (unset) def
    /addontextxoffset (unset) def
    /addontextyoffset (unset) def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   
    addontextfont (unset) ne {/addontextfont addontextfont cvlit def} if
    addontextsize (unset) ne {/addontextsize addontextsize cvr def} if
    addontextxoffset (unset) ne {/addontextxoffset addontextxoffset cvr def} if
    addontextyoffset (unset) ne {/addontextyoffset addontextyoffset cvr def} if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Validate the input
    barcode length 12 ne barcode length 13 ne and {
        /bwipp.ean13badLength (EAN-13 must be 12 or 13 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean13badCharacter (EAN-13 must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.ean13badAddOnLength (Add-on for EAN-13 must be 2 or 5 digits) //raiseerror exec
    } if

    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 13 eq {
        barcode 12 get checksum 48 add ne {
            /bwipp.ean13badCheckDigit (Incorrect EAN-13 check digit provided) //raiseerror exec
        } if
    } if
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 14 add textxoffset add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 18 add textxoffset add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset addontextxoffset (unset) ne {addontextxoffset} {95 addongap add} ifelse
            addontextyoffset (unset) ne {/textyoffset addontextyoffset} if
            /textsize addontextsize (unset) ne {addontextsize} {textsize} ifelse
            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean13 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean13--

% --BEGIN ENCODER issn--
% --REQUIRES preamble raiseerror renlinear ean2 ean5 ean13--
% --DESC: ISSN
% --EXAM: 0311-175X 00 17
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp issn 0.0 2016110200 85135 81376
%%BeginData:        177 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/issn {

    20 dict begin

    /options exch def      % We are given an options string
    /issntxt exch def      % We are given the issn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISSN text
    /issntextfont /Courier def
    /issntextsize 9 def
    /issntextxoffset (unset) def
    /issntextyoffset (unset) def
    /height 1 def
    /addongap 12 def   

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /issntextfont issntextfont cvlit def
    /issntextsize issntextsize cvr def
    issntextxoffset (unset) ne {/issntextxoffset issntextxoffset cvr def} if
    issntextyoffset (unset) ne {/issntextyoffset issntextyoffset cvr def} if
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the ISSN
    issntxt ( ) search {
        /issntxt exch def
        pop
        /seqvar exch def
    } { 
        pop
        /seqvar () def
    } ifelse

    % Split off the sequence variant and addon
    seqvar ( ) search {
        /seqvar exch def
        pop
        /addon exch def
    } {
        pop
        /addon seqvar def
        /seqvar (00) def
    } ifelse

    % Validate the input
    issntxt length 8 ne issntxt length 9 ne and {
        /bwipp.issnBadLength (ISSN must be 8 or 9 characters including dash) //raiseerror exec
    } if
    issntxt 0 4 getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } forall
    issntxt 4 1 getinterval (-) ne {
        /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
    } if
    issntxt 5 3 getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } forall
    issntxt length 9 eq {
        issntxt 8 get dup dup 48 lt exch 57 gt or exch 88 ne and {  % Digits or X
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } if
    seqvar length 2 ne {
        /bwipp.issnBadSequenceVariantLength (Sequence variant for ISSN must be 2 digits) //raiseerror exec
    } if
    seqvar {
        dup 48 lt exch 57 gt or {
           /bwipp.issnSequenceVariantBadCharacter (Sequence variant for ISSN must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.issnBadAddOnLength (Add-on for ISSN must be 2 or 5 digits) //raiseerror exec
    } if

    % Read the digits from issntxt and calculate checksums
    /issn 8 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /issnchar issntxt i get 48 sub def
        issnchar -3 ne {           % Ignore dashes
            issn n issnchar 48 add put
            n 7 lt {
                /checksum checksum issnchar 8 n sub mul add def
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i issntxt length eq {exit} if
    } loop
    /checksum 11 checksum 11 mod sub 11 mod def
    /checksum checksum 48 add dup 58 eq {pop 88} if def
    issntxt length 9 eq {
        issntxt 8 get checksum ne {
            /bwipp.issnBadCheckDigit (Incorrect ISSN check digit provided) //raiseerror exec
        } if
    } if

    % Add the ISSN header and checksum to the issntxt
    /pad 14 string def
    pad 0 (ISSN ) putinterval
    pad 5 issntxt putinterval  % Add issntxt to the pad
    pad 13 checksum put
    /issntxt pad def

    % Convert ISSN digits to EAN-13
    /barcode issn 0 7 getinterval def 

    % Append the sequence variant
    /barcode 12 string def
    barcode 0 (977) putinterval
    barcode 3 issn putinterval
    barcode 10 seqvar putinterval

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISSN text
% This is all commented out to prevent the printing
% of ‘ISSN XXXX-XXXX’ above the barcode as standard
%    includetext {
%        issntextxoffset (unset) eq {/issntextxoffset 10 def} if
%        issntextyoffset (unset) eq {
%            /issntextyoffset height 72 mul 3 add def
%        } if
%        args (txt) known {
%            /txt args (txt) get def
%            /newtxt txt length 1 add array def
%            newtxt 0 txt putinterval
%            newtxt newtxt length 1 sub [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] put
%            args (txt) newtxt put
%        } {
%            args (txt) [ [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] ] put
%        } ifelse
%    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/issn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER issn--

% --END TEMPLATE--
